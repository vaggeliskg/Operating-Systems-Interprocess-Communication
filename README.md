ΕΥΑΓΓΕΛΟΣ ΚΑΛΑΜΠΟΚΗΣ
1115202100045

Η εργασία αποτελείται από 2 .c αρχεία το PA και το  PB. Αρχικά και στις 2 main δημιουργείται επιτυχημένα το shared memory segment, δημιουργούνται τα threads sender, receiver που περιέχουν μια while που λειτουργεί όσο τρέχει το πρόγραμμα ώστε να είναι σε θέση να στείλουν μηνύματα αλλά και να λάβουν ανά πάσα στιγμή 
και αρχικοποιούνται οι απαραίτητες μεταβλητές που χρησιμοποιούνται στο struct shared_stuff. Συγκεκριμένα χρησιμοποιούνται στο struct τα εξής:

1. int A, int B: Μεταβλητή που δείχνει αν έγραψε ο Α ή ο Β αντίστοιχα κα γίνεται 1 
όταν στέλνεται μήνυμα και 0 στην receive του ίδιου process όπου γίνεται και empty το local_buffer. Επίσης χρησιμοποιείται και για να αναγνωρίσει ποιο process έληξε με #BYE# το interaction. Αν δηλαδή το έληξε το PB, το B = 1 γιατί αυτό έγραψε τελευταίο και στο PA το sender θα γίνει cancelled για να μην περιμένει στην fgets και να τερματίζει ταυτόχρονα, στο PB το sender θα εκτελέσει κανονικά τη join χωρίς να γίνει cancel.



2. char some_text_for_PA[TEXT_SZ], char some_text_for_PB[TEXT_SZ]:
Αυτοί οι 2 πίνακες δεν είναι κάτι παραπάνω από πίνακες χαρακτήρων μεγέθους TEXT_SZ όπως ήταν στο φροντιστήριο. Σε αυτά τα arrays καταλήγει το μήνυμα αφού γραφτεί στο εκάστοτε local buffer είτε περάσει από διαίρεση σε πακέτα αν είναι > 15 χαρακτήρες είτε όχι. Δηλαδή από το PA το μήνυμα προκειμένου να φτάσει σε σημείο να διαβαστεί από το PB θα πρέπει να βρεθεί στο some_text_for_PA.

3. char *local_buffer_PA, char *local_buffer_PB: Δείκτες στο εκάστοτε process buffer που χρησιμοποιούνται για να παίρνουν το input από το τερματικό και είτε το περνάνε στο some_text_for_PA, some_text_for_PB είτε σε packets που μετά περνάνε στα some_text_for_PA/PB

4. int running: μεταβλητή που χρησιμοποιείται στις while των threads , γίνεται 0 όταν γραφτεί #BYE# από κάποιο process.

5. sem_t semA_test, sem_t semB_test: Semaphores για τον απαραίτητο συγχρονισμό των processes. Όταν στέλνεται ένα μήνυμα ή και πακέτο από το PA για παράδειγμα, γίνεται post το semB_test, οπότε τρέχει το receive του PB και αμέσως γίνεται wait στη receive περιμένοντας δηλαδή να ξαναλάβει μήνυμα αφόυ εκτελεστεί μια φορά πρώτα.

6. int message_via_packets_A, int messages_via_packets_B: Μεταβλητές που ελέγχουν αν ένα μήνυμα διαρείται σε πακέτα. Αυτό είναι απαραίτητο γιατί στην ουσία τόσο το sender όσο και το receiver χωρίζονται σε 2 τμήματα. Το 1ο τμήμα αναλαμβάνει τη διαχείριση μηνυμάτων αν το μήνυμα είναι > 15 χαρακτήρες και το 2ο τμήμα αν είναι < 15 χαρακτήρες. Αν λοιπόν το message_via_packets_A == 1 σημαίνει ότι ο Α στέλνει μήνυμα που διαρείται σε πακέτα όποτε ειδοποιεί τη receiver ότι τέτοια διαχείριση θα χρειαστεί μόλις επεξεργαστεί όλο το μήνυμα το full_message γίνεται 1, το εκτυπώνει και κάνει το message_via_packets_A = 0.

7. sem_t packet_sent_from_A, sem_t packet_sent_from_B: Απαραίτητα semaphores που χρησιμοποιούνται για τη διαχείριση μηνυμάτων που διαρούνται σε πακέτα, όταν σταλθεί ένα πακέτο από το PA για παράδειγμα το packet_sent_from_A γίνεται wait οπότε περιμένει πριν να στείλει και άλλο πακέτο να το πάρει πρώτα το receiver του PB να το διαχειριστεί κάνοντας παράλληλα post το packet_sent_from_A.

8. int number_of_A_messages, int number_of_B_messages: Ο αριθμός μηνυμάτων που έστειλε το κάθε process

9. int number_of_A_packets, int number_of_B_packets: Ο αριθμός μηνυμάτων που έστειλε το κάθε process

10. long int time_for_A, long int time_for_B: Άθροισμα των χρόνων που απαιτείται από την αποστολή του πρώτου πακέτου μέχρι την παραλαβή του. 

11. struct timeval tv_A, struct timeval tv_B: δομή που χρησιμοποιείται για να μετρηθεί η ώρα που στάλθηκε το πρώτο πακέτο ( ή το μοναδικό πακέτο αν το μήνυμα είναι < 15 χαρακτήρες). Στη receiver χρησιμοποείται τοπικά άλλη μια τέτοια δομή που μετράει την ώρα της παραλαβής , οπότε γίνεται η αφαίρεση tv_B, tv_receive_A για το Α

12. int first_packet_A, int first_packet_B: Μεταβλητή που είναι 1 αν μιλάμε για το πρώτο πακέτο ενός μηνύματος που αποτελείται από > 1 πακέτα 

ΤΕΧΝΙΚΕΣ ΛΕΠΤΟΜΕΡΕΙΕΣ: 
1. Όπως προαναφέρθηκε η διαχείριση των μηνυμάτων χωρίζεται σε > 15 χαρακτήρες και < 15 χαρακτήρες. Στη receiver όταν πρόκειται για πακέτο που αποτελεί μέρος μηνύματος χρησιμοποιείται όχι η strcpy αλλά η strcat προκειμένου το κάθε πακέτο να τοποθετείται δίπλα από το προηγούμενο κατασκευάζοντας το τελικό μήνυμα , οπότε είναι απαραίτητη και η εντολή shared_stuff->local_buffer_PA[0] = '\0'; αφού σταλθεί ένα μήνυμα από τον Α ώστε το μήνυμα που θα δεχθεί να μην γραφτεί σε buffer που έχει μέσα το μήνυμα που μόλις έστειλε, χρησιμοποιείται και όταν διαβαστεί ένα μήνυμα (ολόκληρο) για την αποφυγή τέτοιων προβλημάτων.

2. Είτε το PA είτε το PB μπορούν να ξεκινήσουν αλλά και να λήξουν την ανταλλαγή στέλνοντας όσα μηνύματα θέλουν

3. Σχόλια υπάρχουν μόνο στο PA αφού τα ίδια και αντίστοιχα ισχύουν για το PB

4. Δεν υπάρχει ιδιαίτερος λόγος που χρησιμοποιήθηκε BUFSIZ/2 αντί για BUFSIZ, το αποτέλεσμα θα ήταν το ίδιο ,απλά το έθεσα ως BUFSIZ/2 λόγω μιας απάντησης που είχε δωθεί στο eclass "Το default buffer size για stdin (terminal) είναι 1 page στο Linux, δηλαδή 4096  bytes. Επειδή είναι implementation-defined, μπορεί να είναι είτε μικρότερο είτε μεγαλύτερο σε κάθε σύστημα."

5. Η εργασία γράφτηκε και δοκιμάστηκε στα linux της σχολής

Ενδεικτική εκτέλεση:

![Alt text](<Screenshot 2023-11-25 at 4.12.25 PM.png>)

Ελπίζω τα σχόλια και το README να κάλυψαν τις λεπτομέρειες και τις σχεδιαστικές επιλογές μου :)